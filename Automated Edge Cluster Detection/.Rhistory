filter(paste(ElementName, ">=", CutOffBValue)))$"Distance"),
colour="red") +
geom_text(aes(min((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffAValue)))$"Distance")/2,
CutOffAValue,label="Phase A cutoff value", vjust = -0.5),
colour="blue") +
geom_text(aes((max((ElementCountDF)$"Distance")-
(max((ElementCountDF)$"Distance")-
max((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffBValue)))$"Distance"))/2),
CutOffBValue,label="Phase B cutoff value", vjust = -0.5),
colour="red") +
geom_text(aes(min((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffAValue)))$"Distance"),
0,label="Interface Start",hjust=1.2),
colour="blue") +
geom_text(aes(max((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffBValue)))$"Distance"),
0,label="Interface End",hjust=-0.2),
colour="red") +
theme_bw() +
ggtitle(paste0(ElementName," Counts vs Distance")) +
theme(plot.title = element_text(hjust = 0.5))
)
ThresholdSuitableCheck()
}
ggplot(ElementCountDF %>%
gather(Element, value, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element != "O") %>%
mutate(`Concentration (at.%)` = 100 * (value/Atom_Count)),
aes(Distance, `Concentration (at.%)`)) +
theme_bw() +
geom_line(aes(colour = Element))
DeterminingElementForThresholdCalculations()
#### Defining Start and End of GB ####
GrainA <- ElementCountDF %>% filter(Distance < min((ElementCountDF %>% filter(paste(ElementName, ">=", CutOffAValue)))$"Distance"))
GrainB <- ElementCountDF %>% filter(Distance > max((ElementCountDF %>% filter(paste(ElementName, ">=", CutOffBValue)))$"Distance"))
GB <- ElementCountDF %>%
filter(Distance < min(GrainB$Distance)) %>%
filter(Distance > max(GrainA$Distance))
source("../GE Calculator Two.R")
GibbsExcessCalculator(Area,DetectionEfficiency) #ROI Area and machine detection efficiency
GrainBoundarySumm <- function() {
GBWidth <<- max(GB$Distance) - min(GB$Distance)
GBComp <- as.data.frame(colSums(GB %>%
select(-Distance,-Ion_Count,-Atom_Count)))
Total = sum(GBComp)
GBComp <- GBComp %>%
rownames_to_column("Element") %>%
mutate(Composition = 100 * `colSums(GB %>% select(-Distance, -Ion_Count, -Atom_Count))` /
Total)
GBSummary <<- cbind(GBComp,
GibbsExcess %>%
select(-Element)) %>%
select(Element,
Composition,
GibbsExcess,
GibbsExcessLower,
GibbsExcessUpper,
GrainAFraction,
GrainBFraction) %>%
mutate(
LowerErr = abs(GibbsExcess - GibbsExcessLower),
UpperErr = abs(GibbsExcess - GibbsExcessUpper)
) %>%
transmute(
Element = Element,
`Interface Composition (at.%)` = round(Composition,4),
`Gibbs Excess` = GibbsExcess,
`Gibbs Error` = pmax(LowerErr, UpperErr),
`Phase A Composition (at.%)` = round(100 * GrainAFraction,4),
`Phase B Composition (at.%)` = round(100 * GrainBFraction,4)
)
print(GBSummary)
write.csv(GBSummary,"Grain Boundary Calculations.csv",
row.names = FALSE)
print(paste0("Width of interface is: ",round(GBWidth,2)," nm (2dp)"))
}
GrainBoundarySumm()
setwd(dirname(parent.frame(2)$ofile))
#Area of ROI in nm
Area <- 225
# Detection Efiiciency of LEAP
DetectionEfficiency <- 0.37
# CSV file path for 1D conc profile
CSVFilePath <- c("D:/DPhilY1/Thesis/ThesisAPTImages/NeutronIrrad/Run7727/GB ROI 15x15nm.csv")
CSVFilePath
source("../Determine Gibbs Excess.R")
print(ggplot(ElementCountDF %>%
gather(Element, value, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element == ElementName),
aes(Distance, value)) +
geom_line(colour = "black") +
theme_bw())
ggplot(ElementCountDF %>%
gather(Element, value, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element != "O") %>%
mutate(`Concentration (at.%)` = 100 * (value/Atom_Count)),
aes(Distance, `Concentration (at.%)`)) +
theme_bw() +
geom_line(aes(colour = Element))
source("../Determine Gibbs Excess.R")
source("../Determine Gibbs Excess.R")
ggplot(ElementCountDF %>%
gather(Element, value, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element != "O") %>%
mutate(`Concentration (at.%)` = 100 * (value/Atom_Count)),
aes(Distance, `Concentration (at.%)`)) +
theme_bw() +
geom_line(aes(colour = Element))
print(ggplot(ElementCountDF %>%
gather(Element, value, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element != "O") %>%
mutate(`Concentration (at.%)` = 100 * (value/Atom_Count)),
aes(Distance, `Concentration (at.%)`)) +
theme_bw() +
geom_line(aes(colour = Element)))
source("../Determine Gibbs Excess.R")
#Area of ROI in nm
Area <- 225
# Detection Efiiciency of LEAP
DetectionEfficiency <- 0.37
# CSV file path for 1D conc profile
CSVFilePath <- c("D:/DPhilY1/Thesis/ThesisAPTImages/NeutronIrrad/Run7727/GB ROI 15x15nm.csv")
ImportedData <- read.csv(paste0(CSVFilePath),
header =TRUE, sep =",", quote="\"",
check.names=F, strip.white=TRUE)
names(ImportedData) <- gsub(" %", "", names(ImportedData))  #Replaces "C %" with "C"
names(ImportedData) <- gsub("\\(","",names(ImportedData))   #Removes ( parentheses
names(ImportedData) <- gsub("\\)","",names(ImportedData))   #Removes ) parentheses
names(ImportedData) <- gsub(" ", "_", names(ImportedData))  #Replaces white space with _
names(ImportedData) <- gsub("Distance_nm", "Distance", names(ImportedData))
ImportedData <- ImportedData[, -grep("Sigma", colnames(ImportedData))]
#### Creating dataframe after decomposing ions ####
CountDF <- ImportedData %>%
gather("Ion", "value", -Distance, -Ion_Count, -Atom_Count) %>%
mutate(value = value * Atom_Count/100) %>%
spread("Ion", "value")
data("periodicTable")
ElementsList <- c(unique(periodicTable$symb))
ElementCountDF <- CountDF
for(Ions in colnames(CountDF %>% select(-Distance, -Atom_Count, -Ion_Count))){
if(Ions %in% unique(periodicTable$symb) == FALSE){
SplitIon <- CountChemicalElements(Ions)
i <- 1
for(DecomposedElements in names(SplitIon[])){
ElementCountDF <- ElementCountDF %>%
mutate(!!paste((DecomposedElements), sep = "_") := (!!rlang::sym(paste((DecomposedElements), sep = "_"))) +
((!!rlang::sym(paste((Ions), sep = "_"))) * as.numeric(SplitIon[i])))
i < i + 1
}
ElementCountDF <- ElementCountDF %>% select(-Ions)
}
}
rm(DecomposedElements, i, Ions, SplitIon, ElementsList) # Remove vars from global envir
print(ggplot(ElementCountDF %>%
gather(Element, value, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element != "O") %>%
mutate(`Concentration (at.%)` = 100 * (value/Atom_Count)),
aes(Distance, `Concentration (at.%)`)) +
theme_bw() +
geom_line(aes(colour = Element)))
print(ggplot(ElementCountDF %>%
gather(Element, value, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element != "O") %>%
mutate(`Concentration (at.%)` = 100 * (value/Atom_Count)),
aes(Distance, `Concentration (at.%)`)) +
theme_bw() +
geom_line(aes(colour = Element)))
getwd()
getSrcDirectory()[1]
source('~/GitHub/APT-Data-Analysis/Gibbs Excess Calculator.R')
source('~/GitHub/APT-Data-Analysis/Gibbs Excess Calculator.R')
source('~/GitHub/APT-Data-Analysis/Gibbs Excess Calculator.R')
ThresholdCheckFunction()
GrainADistance
GrainBDistance
AdjustedPValue
AdjustedPValue <- 1 - (1 - PValue)^(1/nrow(ElementCountDF))
x <- 1
Prob <- 1
while(Prob >= AdjustedPValue){
Prob <- ppois(x, lambda = mean((ElementCountDF %>% filter(Distance <= GrainADistance))[[ElementName]]), lower=FALSE)
x <- x + 1
}
CutOffAValue <<- x
CutOffAValue
y <- 1
Prob <- 1
while(Prob >= AdjustedPValue){
Prob <- ppois(y, lambda = mean((ElementCountDF %>% filter(Distance >= GrainBDistance))[[ElementName]]), lower=FALSE)
y <- y + 1
}
CutOffBValue <<- y
CutOffBValue
print(ggplot(ElementCountDF %>%
gather(Element, `Counts in Bin`, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element == ElementName),
aes(Distance, `Counts in Bin`)) +
geom_line(colour = "black") +
geom_hline(yintercept = CutOffAValue,
colour="blue",
linetype="dashed") +
geom_hline(yintercept = CutOffBValue,
colour="red",
linetype="dashed") +
geom_vline(xintercept = min((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffAValue)))$"Distance"),
colour="blue") +
geom_vline(xintercept = max((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffBValue)))$"Distance"),
colour="red") +
geom_text(aes(min((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffAValue)))$"Distance")/2,
CutOffAValue,label="Phase A cutoff value", vjust = -0.5),
colour="blue") +
geom_text(aes((max((ElementCountDF)$"Distance")-
(max((ElementCountDF)$"Distance")-
max((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffBValue)))$"Distance"))/2),
CutOffBValue,label="Phase B cutoff value", vjust = -0.5),
colour="red") +
geom_text(aes(min((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffAValue)))$"Distance"),
0,label="Interface Start",hjust=1.2),
colour="blue") +
geom_text(aes(max((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffBValue)))$"Distance"),
0,label="Interface End",hjust=-0.2),
colour="red") +
theme_bw() +
ggtitle(paste0(ElementName," Counts vs Distance")) +
theme(plot.title = element_text(hjust = 0.5))
)
ElementCountDF %>%
gather(Element, `Counts in Bin`, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element == ElementName)
min((ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffAValue)))$"Distance")
ElementName
CutOffAValue
ElementCountDF %>%
filter(paste(ElementName, ">=", CutOffAValue))
ElementCountDF %>% filter(Ni >= 16)
ElementCountDF %>%
filter(paste0(ElementName, ">=", CutOffAValue))
ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffAValue))
print(ggplot(ElementCountDF %>%
gather(Element, `Counts in Bin`, -Distance, -Ion_Count,-Atom_Count) %>%
filter(Element == ElementName),
aes(Distance, `Counts in Bin`)) +
geom_line(colour = "black") +
geom_hline(yintercept = CutOffAValue,
colour="blue",
linetype="dashed") +
geom_hline(yintercept = CutOffBValue,
colour="red",
linetype="dashed") +
geom_vline(xintercept = min((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffAValue)))$"Distance"),
colour="blue") +
geom_vline(xintercept = max((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffBValue)))$"Distance"),
colour="red") +
geom_text(aes(min((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffAValue)))$"Distance")/2,
CutOffAValue,label="Phase A cutoff value", vjust = -0.5),
colour="blue") +
geom_text(aes((max((ElementCountDF)$"Distance")-
(max((ElementCountDF)$"Distance")-
max((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffBValue)))$"Distance"))/2),
CutOffBValue,label="Phase B cutoff value", vjust = -0.5),
colour="red") +
geom_text(aes(min((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffAValue)))$"Distance"),
0,label="Interface Start",hjust=1.2),
colour="blue") +
geom_text(aes(max((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffBValue)))$"Distance"),
0,label="Interface End",hjust=-0.2),
colour="red") +
theme_bw() +
ggtitle(paste0(ElementName," Counts vs Distance")) +
theme(plot.title = element_text(hjust = 0.5))
)
source('~/GitHub/APT-Data-Analysis/Gibbs Excess Calculator.R')
source('~/GitHub/APT-Data-Analysis/Gibbs Excess Calculator.R')
#Import: POS File, Cluster Range File, Cluster Analysis CSV in that order
FilePaths <-
c(
"D:/DPhilY1/Data/F-330C-11688h/Run27511/AlloyF-330-11688h-Run27511/recons/k4.5/Carbide2atRemovedpos2/Carbide2atRemovedpos2.pos",
"D:/DPhilY1/Data/F-330C-11688h/Run27511/AlloyF-330-11688h-Run27511/recons/k4.5/Carbide2atRemovedpos2/Carbide2atRemovedpos2.cluster.indexed.rrng",
"D:/DPhilY1/Data/ClusterCompositions/ThermalAgeingClusters/Carbide2atRemovedpos2 - Top-Level ROI - Cluster Analysis (Si, Ni, Cu, Fm, Mn, P).csv"
)
#This function allows one to import a pos file into R with x, y, z, and mass-to-charge-ratio information
readposR <- function(posFileName) {
# size of floats = 4 bytes
sizeOfFloat = 4
# get file size
fileInfo <- file.info(posFileName)
fileSize <- fileInfo$size / sizeOfFloat
to.read = file(posFileName, "rb")
posFile <- readBin(to.read,
double(),
size = 4,
n = fileSize,
endian = "big")
close(to.read)
posFile <-
t(matrix(posFile, nrow = 4, dimnames = list(c("x", "y", "z", "m"))))
posFile <- as.data.frame(posFile)
return(posFile)
}
#This function creates a new range file (in the same location as the original range file)
#The new range file will have edge clusters coloured red and non-edge clusters coloured blue
EdgeClusterRangeFileWriter <- function(RangeFilePath) {
ClusterRangeFileImp <-
read.delim(RangeFilePath)
ClusterRangeFile <- ClusterRangeFileImp %>%
filter(grepl("Color", `X.Ions.`))  %>%
separate(`X.Ions.`, c("X.Ions.", "Colour"), sep = "Color:")
ClusterEdgeColour <-
cbind(ClusterRangeFile, EdgeForExcelClusterImport)
ClusterEdgeColour <- ClusterEdgeColour %>%
rowwise() %>%
mutate(Colour2 = if_else(
is.na(Edge),
paste0(sample(c(
"00", "05", "10", "15", "20", "30", "35", "40", "45", "50", "55", "60"
), 1),
sample(c(
"00", "05", "10", "15", "20", "30", "35", "40", "45", "50", "55", "60"
), 1),
"FF"),
paste0("FF",
sample(c(
"00", "05", "10", "15", "20", "30", "35", "40", "45", "50", "55", "60"
), 1),
sample(c(
"00", "05", "10", "15", "20", "30", "35", "40", "45", "50", "55", "60"
), 1))
)) %>%
mutate(
Colour2 = paste0(" Color:",Colour2)
) %>%
select(X.Ions., Colour2) %>%
unite(X.Ions., `X.Ions.`, Colour2, sep ="")
RangeFileExp <- rbind(ClusterRangeFileImp %>%
filter(!grepl("Color", `X.Ions.`)),
ClusterEdgeColour)
colnames(RangeFileExp) <- c("[Ions]")
write.table(
RangeFileExp,
file = gsub(".rrng", ".EdgeClusterRangeFile.rrng", RangeFilePath),
sep = "\t",
quote = FALSE,
row.names = FALSE
)
}
library(tidyverse)
library("geometry", lib.loc = "~/R/win-library/3.4")
library(spatstat)
posFilePath <- FilePaths[1]
IndexedRangeFilePath <- FilePaths[2]
ClusterImportPath <- FilePaths[3]
#pos file path
posFile <-
readposR(posFilePath)
#cluster file path
ClusterImport <-
read.csv(ClusterImportPath,
skip = 10
)
#### Cluster Import ####
ClusterImport <-
ClusterImport %>% select(
X,
Solute.Ions,
Ranged.Ions,
Total.Ions,
Center_x..nm..Ranged,
Center_y..nm..Ranged,
Center_z..nm..Ranged,
Extent_x..nm..Ranged,
Extent_y..nm..Ranged,
Extent_z..nm..Ranged
) %>%
mutate(
x_max = Center_x..nm..Ranged + Extent_x..nm..Ranged,
x_min = Center_x..nm..Ranged - Extent_x..nm..Ranged,
y_max = Center_y..nm..Ranged + Extent_y..nm..Ranged,
y_min = Center_y..nm..Ranged - Extent_y..nm..Ranged,
z_max = Center_z..nm..Ranged + Extent_z..nm..Ranged,
z_min = Center_z..nm..Ranged - Extent_z..nm..Ranged
) %>%
filter(grepl("Cluster", X))
#### Find extreme co-ords for each cluster (modelling as cuboids) ####
ClusterImport <- ClusterImport %>%
mutate(
ClusterID = as.numeric(gsub("Cluster ", "", X)),
Point1 = paste0(x_max, ",", y_max, ",", z_max),
Point2 = paste0(x_max, ",", y_max, ",", z_min),
Point3 = paste0(x_max, ",", y_min, ",", z_max),
Point4 = paste0(x_max, ",", y_min, ",", z_min),
Point5 = paste0(x_min, ",", y_max, ",", z_max),
Point6 = paste0(x_min, ",", y_max, ",", z_min),
Point7 = paste0(x_min, ",", y_min, ",", z_max),
Point8 = paste0(x_min, ",", y_min, ",", z_min)
) %>%
select(ClusterID,
Point1,
Point2,
Point3,
Point4,
Point5,
Point6,
Point7,
Point8) %>%
gather(Point, value, -ClusterID) %>%
arrange(ClusterID) %>%
separate(value, c("x", "y", "z"), sep = ",") %>%
mutate(x = as.numeric(x),
y = as.numeric(y),
z = as.numeric(z))
ClusterLocationMatrix <-
as.matrix(ClusterImport %>% select(x, y, z))
#### Filter pos file to improve speed ####
PosFraction <- floor(nrow(posFile) * SamplingFraction)
#### Parameters For Calculating Alpha Value####
# How much one would like to sample the POS file by
SamplingFraction <- 0.005
#### Filter pos file to improve speed ####
PosFraction <- floor(nrow(posFile) * SamplingFraction)
FilterPosFile <- posFile %>% sample_n(PosFraction)
AlphaValue <- 2*round(ceiling(100*max(nndist(FilterPosFile %>% select(x,y,z), k=1))),2)/100
print(paste0(
"Alpha Value: ",
AlphaValue,
" Sampling fraction: ",
SamplingFraction
))
#### Using alpha-shape 3d ####
library("alphashape3d", lib.loc = "~/R/win-library/3.4")
AlphaHullShape <-
ashape3d(as.matrix(FilterPosFile[, 1:3]), alpha =  c(AlphaValue, 2*AlphaValue))
#plot(AlphaHullShape, indexAlpha = 1)
#### Ensuring there is only one connected volume ####
comp <- components_ashape3d(AlphaHullShape, indexAlpha = "all")
NumberVolumes <- as.data.frame(table(comp[[1]]))
if (nrow(NumberVolumes) != 1) {
print(paste0("Error. Multiple volumes created"))
} else{
print(paste0("Alpha value has created one volume"))
# determining which clusters are edge clusters
ClustersInHull <-
inashape3d(AlphaHullShape, indexAlpha = 1, ClusterLocationMatrix)
# getting names of clusters that are edge
ClusterLocation2 <- cbind(ClusterImport, ClustersInHull) %>%
filter(ClustersInHull == "FALSE")
TotalEdgeClusters <-
as.data.frame(unique(ClusterLocation2$ClusterID))
TotalEdgeClusters <-
TotalEdgeClusters %>% transmute(ID = gsub("Cluster ", "", unique(ClusterLocation2$ClusterID)))
TotalEdgeClusters <- sort(TotalEdgeClusters$ID)
EdgeForExcelClusterImport <-
ClusterImport %>% select(ClusterID) %>% distinct(ClusterID)
EdgeForExcelClusterImport <-
EdgeForExcelClusterImport %>% mutate(Edge = ifelse(
match(EdgeForExcelClusterImport$ClusterID, TotalEdgeClusters),
"Edge",
""
))
write.table(EdgeForExcelClusterImport,
"clipboard",
sep = "\t",
row.names = FALSE)
# write.table(
#   EdgeForExcelClusterImport %>% filter(Edge == "Edge") %>% select(ClusterID),
#   "clipboard",
#   sep = "\t",
#   row.names = FALSE
# )
nrow(EdgeForExcelClusterImport %>% filter(Edge == "Edge"))
}
print(paste0(
"Total number of clusters detected: ",
nrow(EdgeForExcelClusterImport %>% filter(Edge == "Edge"))
))
EdgeClusterRangeFileWriter(
IndexedRangeFilePath)
source('~/GitHub/APT-Data-Analysis/Automated Edge Cluster Detection/Edge Cluster Detection Script.R')
source('~/GitHub/APT-Data-Analysis/Automated Edge Cluster Detection/Edge Cluster Detection Script.R')
# View Alpha shape that is generated
plot(AlphaHullShape, indexAlpha = 1)
getwd()
#Import: POS File, Cluster Range File, Cluster Analysis CSV in that order
FilePaths <-
c("TestFiles/006_full.pos",
"TestFiles/006_full.cluster.indexed.rrng",
"TestFiles/006_full - Top-Level ROI - Cluster Analysis (Cu, Ni).csv")
#### Parameters For Calculating Alpha Value####
# How much one would like to sample the POS file by
SamplingFraction <- 0.005
source("AlphaHull.R")
FilePaths <- c("Test Files/006_full.pos",
"Test Files/006_full.cluster.indexed.rrng",
"Test Files/006_full - Top-Level ROI - Cluster Analysis (Cu, Ni).csv")
source("AlphaHull.R")
# View Alpha shape that is generated
plot(AlphaHullShape, indexAlpha = 1)
