ZRange = c(-1, 1),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(90.0,6.0,4.0),
"Mass" = c(1, 2, 3)))
#### Create overall pos ####
SimulatedPos <- rbind(MatrixA, MatrixB, GB)
#Add gaussian noise to z position
SimulatedPos <- SimulatedPos %>%
mutate(z = z + rnorm(n(),0,0.5)) %>%
filter(-10 < z & z < 10)
rm(MatrixA, MatrixB, GB)
#### Input RangeFile and Tidy ####
RangeFile <- read.delim("../Test Pos and Range Files/Range For Simulation.rrng", colClasses = "character", header = FALSE)
RowsToSkip <- as.numeric(gsub("Number=", "", RangeFile[2,])) + 5
Ranges <- RangeFile %>% slice(RowsToSkip:n())
rm(RowsToSkip, RangeFile)
RangesDF <- data.frame()
i = 0
for(i in unique(str_count(Ranges$V1, ":") - 2)){
Elements <- c()
for(j in seq(1,i,1)){
Elements <- append(Elements,paste("Element",j))
}
ColumnNames <- c("Start", "End", "Volume",
Elements, "Color")
Ranges %>%
mutate(NumberIons = str_count(V1, ":") - 2) %>%
filter(NumberIons == i) %>%
separate(V1,
ColumnNames,
sep = " ")
RangesDF <- bind_rows(RangesDF,
Ranges %>%
mutate(NumberIons = str_count(V1, ":") - 2) %>%
filter(NumberIons == i) %>%
separate(V1,
ColumnNames,
sep = " ")
)
}
rm(ColumnNames, Elements,i, j)
#### Creat R-friendly range file ####
RangesDF2 <- cbind(
RangesDF %>%
mutate(Start = as.numeric(str_extract(Start,"[^=]+$")),
End = as.numeric(str_extract(End, "[^=]+$")),
Volume = gsub("Vol:", "", Volume),
Color = gsub("Color:", "", Color)) %>%
select(Start, End, Volume, Color),
RangesDF %>%
select(contains("Element")) %>%
unite("Ion") %>%
mutate(Ion = paste(gsub("1|Name|:|NA|_| ","",Ion)))
)
rm(Ranges, RangesDF)
#### Range pos####
Ion <- data.frame(matrix(NA,
nrow = nrow(SimulatedPos)))
for(i in seq(1,nrow(RangesDF2),1)){
Name <- RangesDF2$Ion[i]
Ion <<- cbind(
Ion,
SimulatedPos %>%
mutate(Name = ifelse(SimulatedPos$m > RangesDF2$Start[i] &
SimulatedPos$m < RangesDF2$End[i],
RangesDF2$Ion[i], NA)) %>%
select(Name))
}
Ion$Noise <- "Noise"
SimulatedPos$Ion <- apply(Ion, 1, function(x) na.omit(x)[1])
rm(i, Ion)
#### Plot one D conc plot ####
ROILength = max(SimulatedPos$z) - min(SimulatedPos$z)
OneDConcPlot <- SimulatedPos %>%
group_by(Distance = cut(z, breaks= seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)),
Ion) %>%
summarise(Ioncount = n()) %>%
ungroup() %>%
spread(Ion, Ioncount) %>%
mutate(Distance = as.numeric(as.character((ceiling(ROILength))*(row_number()/n()))))
SimulatedPos %>%
group_by(Distance = cut(z, breaks= seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)),
Ion)
SimulatedPos %>%
group_by(Distance = cut(z, breaks= seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)),
Ion) %>%
summarise(Ioncount = n()) %>%
ungroup()
View(OneDConcPlot)
unique(OneDConcPlot %>% mutate(Sum = Fe + Ni + P2Si3) %>% select(Sum))
range(SimulatedPos$z)
seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)
SimulatedPos %>% filter(z < -9.9) %>%
group_by(Distance = cut(z, breaks= seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1))
, Ion)
SimulatedPos %>% filter(z < 2 & z > 2) %>%
group_by(Distance = cut(z, breaks= seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)), Ion)
SimulatedPos %>% filter(z < 2 & z > -2) %>%
group_by(Distance = cut(z, breaks= seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)), Ion)
SimulatedPos %>% filter(z < 9 & z > -9) %>%
group_by(Distance = cut(z, breaks= seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)), Ion)
SimulatedPos %>% filter(z < 9.9 & z > -9.9) %>%
group_by(Distance = cut(z, breaks= seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)), Ion)
SimulatedPos %>% filter(z > 9.9) %>%
group_by(Distance = cut(z, breaks= seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)), Ion)
seq(min(SimulatedPos$z), max(SimulatedPos$z), by = 0.1)
seq(floor(min(SimulatedPos$z)), max(SimulatedPos$z), by = 0.1)
seq(floor(min(SimulatedPos$z)), ceiling(max(SimulatedPos$z)), by = 0.1)
OneDConcPlot <- SimulatedPos %>%
group_by(Distance = cut(z, breaks= seq(floor(min(SimulatedPos$z)), ceiling(max(SimulatedPos$z)), by = 0.1)),
Ion) %>%
summarise(Ioncount = n()) %>%
ungroup() %>%
spread(Ion, Ioncount) %>%
mutate(Distance = as.numeric(as.character((ceiling(ROILength))*(row_number()/n()))))
floor(-9.999912)
floor(-9.999912.2)
floor(-9.999912,2)
?floor
# Create function to generate pos file
# Input atomic denisty
# ROI dimensions
library(tidyverse)
POSGenerator <- function(AtomicDensity, XRange, YRange, ZRange,
CompositionTable){
TotalNumberAtoms = AtomicDensity *
(max(XRange)-min(XRange)) *
(max(YRange)-min(YRange)) *
(max(ZRange)-min(ZRange))
x <- sample(seq(min(XRange), max(XRange), 0.00001), TotalNumberAtoms, replace = FALSE)
y <- sample(seq(min(YRange), max(YRange), 0.00001), TotalNumberAtoms, replace = FALSE)
z <- sample(seq(min(ZRange), max(ZRange), 0.00001), TotalNumberAtoms, replace = FALSE)
SimulatedPos <- data.frame(x,y,z) %>%
mutate(m = sample(CompositionTable$Mass, n(), prob = CompositionTable$Abundance, replace = TRUE))
}
#### Generate matrix pos ####
MatrixA <- POSGenerator(AtomicDensity = 40,
XRange = c(-10, 10),
YRange = c(-10, 10),
ZRange = c(-15, -1),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(98.9,1.0,0.1),
"Mass" = c(1, 2, 3)))
MatrixB <- POSGenerator(AtomicDensity = 40,
XRange = c(-10, 10),
YRange = c(-10, 10),
ZRange = c(1, 15),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(98.9,1.0,0.1),
"Mass" = c(1, 2, 3)))
#### GB pos generation ####
GB <- POSGenerator(AtomicDensity = 40,
XRange = c(-10, 10),
YRange = c(-10, 10),
ZRange = c(-1, 1),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(90.0,6.0,4.0),
"Mass" = c(1, 2, 3)))
#### Create overall pos ####
SimulatedPos <- rbind(MatrixA, MatrixB, GB)
#Add gaussian noise to z position
SimulatedPos <- SimulatedPos %>%
mutate(z = z + rnorm(n(),0,0.5)) %>%
filter(-10 < z & z < 10)
rm(MatrixA, MatrixB, GB)
#### Input RangeFile and Tidy ####
RangeFile <- read.delim("../Test Pos and Range Files/Range For Simulation.rrng", colClasses = "character", header = FALSE)
RowsToSkip <- as.numeric(gsub("Number=", "", RangeFile[2,])) + 5
Ranges <- RangeFile %>% slice(RowsToSkip:n())
rm(RowsToSkip, RangeFile)
RangesDF <- data.frame()
i = 0
for(i in unique(str_count(Ranges$V1, ":") - 2)){
Elements <- c()
for(j in seq(1,i,1)){
Elements <- append(Elements,paste("Element",j))
}
ColumnNames <- c("Start", "End", "Volume",
Elements, "Color")
Ranges %>%
mutate(NumberIons = str_count(V1, ":") - 2) %>%
filter(NumberIons == i) %>%
separate(V1,
ColumnNames,
sep = " ")
RangesDF <- bind_rows(RangesDF,
Ranges %>%
mutate(NumberIons = str_count(V1, ":") - 2) %>%
filter(NumberIons == i) %>%
separate(V1,
ColumnNames,
sep = " ")
)
}
rm(ColumnNames, Elements,i, j)
#### Creat R-friendly range file ####
RangesDF2 <- cbind(
RangesDF %>%
mutate(Start = as.numeric(str_extract(Start,"[^=]+$")),
End = as.numeric(str_extract(End, "[^=]+$")),
Volume = gsub("Vol:", "", Volume),
Color = gsub("Color:", "", Color)) %>%
select(Start, End, Volume, Color),
RangesDF %>%
select(contains("Element")) %>%
unite("Ion") %>%
mutate(Ion = paste(gsub("1|Name|:|NA|_| ","",Ion)))
)
rm(Ranges, RangesDF)
#### Range pos####
Ion <- data.frame(matrix(NA,
nrow = nrow(SimulatedPos)))
for(i in seq(1,nrow(RangesDF2),1)){
Name <- RangesDF2$Ion[i]
Ion <<- cbind(
Ion,
SimulatedPos %>%
mutate(Name = ifelse(SimulatedPos$m > RangesDF2$Start[i] &
SimulatedPos$m < RangesDF2$End[i],
RangesDF2$Ion[i], NA)) %>%
select(Name))
}
Ion$Noise <- "Noise"
SimulatedPos$Ion <- apply(Ion, 1, function(x) na.omit(x)[1])
rm(i, Ion)
#### Plot one D conc plot ####
ROILength = max(SimulatedPos$z) - min(SimulatedPos$z)
OneDConcPlot <- SimulatedPos %>%
group_by(Distance = cut(z, breaks= seq(floor(min(SimulatedPos$z)),
ceiling(max(SimulatedPos$z)),
by = 0.1)),
Ion) %>%
summarise(Ioncount = n()) %>%
ungroup() %>%
spread(Ion, Ioncount) %>%
mutate(Distance = as.numeric(as.character((ceiling(ROILength))*(row_number()/n()))))
OneDConcPlot[is.na(OneDConcPlot)] <- 0
ggplot(OneDConcPlot) +
geom_point(aes(Distance, P2Si3))
source("..\Scripts For Grain Boundary Analysis\writeposR.R")
source("../Scripts For Grain Boundary Analysis/writeposR.R")
getwd()
# Create function to generate pos file
# Input atomic denisty
# ROI dimensions
library(tidyverse)
POSGenerator <- function(AtomicDensity, XRange, YRange, ZRange,
CompositionTable){
TotalNumberAtoms = AtomicDensity *
(max(XRange)-min(XRange)) *
(max(YRange)-min(YRange)) *
(max(ZRange)-min(ZRange))
x <- sample(seq(min(XRange), max(XRange), 0.00001), TotalNumberAtoms, replace = FALSE)
y <- sample(seq(min(YRange), max(YRange), 0.00001), TotalNumberAtoms, replace = FALSE)
z <- sample(seq(min(ZRange), max(ZRange), 0.00001), TotalNumberAtoms, replace = FALSE)
SimulatedPos <- data.frame(x,y,z) %>%
mutate(m = sample(CompositionTable$Mass, n(), prob = CompositionTable$Abundance, replace = TRUE))
}
#### Generate matrix pos ####
MatrixA <- POSGenerator(AtomicDensity = 40,
XRange = c(-10, 10),
YRange = c(-10, 10),
ZRange = c(-15, -1),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(98.9,1.0,0.1),
"Mass" = c(1, 2, 3)))
MatrixB <- POSGenerator(AtomicDensity = 40,
XRange = c(-10, 10),
YRange = c(-10, 10),
ZRange = c(1, 15),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(98.9,1.0,0.1),
"Mass" = c(1, 2, 3)))
#### GB pos generation ####
GB <- POSGenerator(AtomicDensity = 40,
XRange = c(-10, 10),
YRange = c(-10, 10),
ZRange = c(-1, 1),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(90.0,6.0,4.0),
"Mass" = c(1, 2, 3)))
#### Create overall pos ####
SimulatedPos <- rbind(MatrixA, MatrixB, GB)
#Add gaussian noise to z position
SimulatedPos <- SimulatedPos %>%
mutate(z = z + rnorm(n(),0,0.5)) %>%
filter(-10 < z & z < 10)
rm(MatrixA, MatrixB, GB)
#### Input RangeFile and Tidy ####
RangeFile <- read.delim("../Test Pos and Range Files/Range For Simulation.rrng", colClasses = "character", header = FALSE)
RowsToSkip <- as.numeric(gsub("Number=", "", RangeFile[2,])) + 5
Ranges <- RangeFile %>% slice(RowsToSkip:n())
rm(RowsToSkip, RangeFile)
RangesDF <- data.frame()
i = 0
for(i in unique(str_count(Ranges$V1, ":") - 2)){
Elements <- c()
for(j in seq(1,i,1)){
Elements <- append(Elements,paste("Element",j))
}
ColumnNames <- c("Start", "End", "Volume",
Elements, "Color")
Ranges %>%
mutate(NumberIons = str_count(V1, ":") - 2) %>%
filter(NumberIons == i) %>%
separate(V1,
ColumnNames,
sep = " ")
RangesDF <- bind_rows(RangesDF,
Ranges %>%
mutate(NumberIons = str_count(V1, ":") - 2) %>%
filter(NumberIons == i) %>%
separate(V1,
ColumnNames,
sep = " ")
)
}
rm(ColumnNames, Elements,i, j)
#### Creat R-friendly range file ####
RangesDF2 <- cbind(
RangesDF %>%
mutate(Start = as.numeric(str_extract(Start,"[^=]+$")),
End = as.numeric(str_extract(End, "[^=]+$")),
Volume = gsub("Vol:", "", Volume),
Color = gsub("Color:", "", Color)) %>%
select(Start, End, Volume, Color),
RangesDF %>%
select(contains("Element")) %>%
unite("Ion") %>%
mutate(Ion = paste(gsub("1|Name|:|NA|_| ","",Ion)))
)
rm(Ranges, RangesDF)
#### Range pos####
Ion <- data.frame(matrix(NA,
nrow = nrow(SimulatedPos)))
for(i in seq(1,nrow(RangesDF2),1)){
Name <- RangesDF2$Ion[i]
Ion <<- cbind(
Ion,
SimulatedPos %>%
mutate(Name = ifelse(SimulatedPos$m > RangesDF2$Start[i] &
SimulatedPos$m < RangesDF2$End[i],
RangesDF2$Ion[i], NA)) %>%
select(Name))
}
Ion$Noise <- "Noise"
SimulatedPos$Ion <- apply(Ion, 1, function(x) na.omit(x)[1])
rm(i, Ion)
#### Plot one D conc plot ####
ROILength = max(SimulatedPos$z) - min(SimulatedPos$z)
OneDConcPlot <- SimulatedPos %>%
group_by(Distance = cut(z, breaks= seq(floor(min(SimulatedPos$z)),
ceiling(max(SimulatedPos$z)),
by = 0.1)),
Ion) %>%
summarise(Ioncount = n()) %>%
ungroup() %>%
spread(Ion, Ioncount) %>%
mutate(Distance = as.numeric(as.character((ceiling(ROILength))*(row_number()/n()))))
OneDConcPlot[is.na(OneDConcPlot)] <- 0
ggplot(OneDConcPlot) +
geom_point(aes(Distance, P2Si3))
source("../Scripts For Grain Boundary Analysis/writeposR.R")
writeposR(SimulatedPos, "Simulated GB.pos")
writeposR(SimulatedPos %>% select(-Ion), "Simulated GB.pos")
POSGenerator <- function(AtomicDensity, XRange, YRange, ZRange,
CompositionTable){
TotalNumberAtoms = AtomicDensity *
(max(XRange)-min(XRange)) *
(max(YRange)-min(YRange)) *
(max(ZRange)-min(ZRange))
x <- sample(seq(min(XRange), max(XRange), 0.00001), TotalNumberAtoms, replace = FALSE)
y <- sample(seq(min(YRange), max(YRange), 0.00001), TotalNumberAtoms, replace = FALSE)
z <- sample(seq(min(ZRange), max(ZRange), 0.00001), TotalNumberAtoms, replace = FALSE)
SimulatedPos <- data.frame(x,y,z) %>%
mutate(m = sample(CompositionTable$Mass, n(), prob = CompositionTable$Abundance, replace = TRUE))
}
#### Generate matrix pos ####
MatrixA <- POSGenerator(AtomicDensity = 40,
XRange = c(-10, 10),
YRange = c(-10, 10),
ZRange = c(-15, -1),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(98.9,1.0,0.1),
"Mass" = c(1, 2, 3)))
MatrixB <- POSGenerator(AtomicDensity = 40,
XRange = c(-10, 10),
YRange = c(-10, 10),
ZRange = c(1, 15),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(98.9,1.0,0.1),
"Mass" = c(1, 2, 3)))
#### GB pos generation ####
GB <- POSGenerator(AtomicDensity = 40,
XRange = c(-10, 10),
YRange = c(-10, 10),
ZRange = c(-1, 1),
CompositionTable = data.frame("Element" = c("Fe", "Ni", "P2Si3"),
"Abundance"= c(90.0,6.0,4.0),
"Mass" = c(1, 2, 3)))
#### Create overall pos ####
SimulatedPos <- rbind(MatrixA, MatrixB, GB)
#Add gaussian noise to z position
SimulatedPos <- SimulatedPos %>%
mutate(z = z + rnorm(n(),0,0.5)) %>%
filter(-10 < z & z < 10)
rm(MatrixA, MatrixB, GB)
View(SimulatedPos)
source('~/GitHub/APT-Data-Analysis/GB Analysis New/POS Generators/PosGenerator.R')
writeposR(SimulatedPos, "../Test Pos and Range Files//Simulated GB.pos")
source('~/GitHub/APT-Data-Analysis/GB Analysis New/Grain Boundary Analysis.R')
setwd("~/GitHub/APT-Data-Analysis/GB Analysis New")
parent.frame(2)
parent.frame(2)$ofile
source('~/GitHub/APT-Data-Analysis/GB Analysis New/POS Generators/PosGenerator.R')
source('~/GitHub/APT-Data-Analysis/GB Analysis New/Grain Boundary Analysis.R')
source('~/GitHub/APT-Data-Analysis/GB Analysis New/Grain Boundary Analysis.R')
min((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffAValue)))$"Distance")
#### Creating dataframe after decomposing ions ####
IonList <- colnames(OneDCount %>%
select(-Distance))
CorrectDF <- data.frame()
for(Ions in IonList){
SplitIon <- CountChemicalElements(Ions)
IonCount <- OneDCount %>%
select(Distance, Ions)
CorrectElementCountInIon = data.frame()
for (Element in 1:length(SplitIon)) {
CorrectElementCount <- cbind(IonCount %>% select(Distance),
((IonCount %>%
select(-Distance))* SplitIon[Element]))
colnames(CorrectElementCount) <- c("Distance", names(SplitIon[Element]))
CorrectElementCount <- CorrectElementCount %>%
gather(Element, Count, -Distance)
CorrectElementCountInIon <<- rbind(CorrectElementCountInIon,CorrectElementCount)
}
CorrectDF <<- rbind(CorrectDF,
CorrectElementCountInIon)
}
ElementCountDF <- CorrectDF %>%
group_by(Element, Distance) %>%
summarise(Count = sum(Count)) %>%
spread(Element, Count) %>%
ungroup()
ElementCountDF <- ElementCountDF %>%
mutate(Atom_Count = rowSums(.[2:ncol(ElementCountDF)]))
rm(IonList, Element, Ions, SplitIon, CorrectDF,
CorrectElementCount, CorrectElementCountInIon) # Remove vars from global envir
ElementName<-readline(prompt="Enter element you would like to use to calculate thresholds: " )
PValue<<-as.numeric(readline(prompt="Enter p-value you would like to use to calculate thresholds (typically 0.05 or 0.01): " ))
if(ElementName %in% colnames(ElementCountDF) == TRUE){
print(paste0(ElementName, " will be used to calculate thresholds with a p-value of ",PValue))
}else{
print(paste0(ElementName, " is not present in your data"))
stop()
}
GrainADistance<<-as.numeric(readline(prompt="Distance up to which the Grain/Phase A is definitely present: " ))
GrainADistance<<-as.numeric(readline(prompt="Distance up to which the Grain/Phase A is definitely present: " ))
GrainBDistance<<-as.numeric(readline(prompt="Distance after which the Grain/Phase B is definitely present: " ))
AdjustedPValue <- 1 - (1 - PValue)^(1/nrow(ElementCountDF))
x <- 1
Prob <- 1
while(Prob >= AdjustedPValue){
Prob <- ppois(x, lambda = mean((ElementCountDF %>% filter(Distance <= GrainADistance))[[ElementName]]), lower=FALSE)
x <- x + 1
}
CutOffAValue <<- x
y <- 1
Prob <- 1
while(Prob >= AdjustedPValue){
Prob <- ppois(y, lambda = mean((ElementCountDF %>% filter(Distance >= GrainBDistance))[[ElementName]]), lower=FALSE)
y <- y + 1
}
CutOffBValue <<- y
#### Defining Start and End of GB ####
GrainA <- ElementCountDF %>% filter(Distance < min((ElementCountDF %>%
filter(UQ(as.symbol(ElementName)) >= CutOffAValue))$Distance))
GrainB <- ElementCountDF %>% filter(Distance > max((ElementCountDF %>%
filter(UQ(as.symbol(ElementName)) >= CutOffBValue))$Distance))
GB <- ElementCountDF %>%
filter(Distance < min(GrainB$Distance)) %>%
filter(Distance > max(GrainA$Distance))
Area <- (max((RangedPos %>% select(-Orientation, -m, -Ion))[1]) -
min((RangedPos %>% select(-Orientation, -m, -Ion))[1]) ) *
(max((RangedPos %>% select(-Orientation, -m, -Ion))[2]) -
min((RangedPos %>% select(-Orientation, -m, -Ion))[2]))
min((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffAValue)))$"Distance")
max((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffBValue)))$"Distance")
min((ElementCountDF %>%
filter(UQ(as.symbol(ElementName) >= CutOffAValue)))$Distance)
min((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffAValue)))$"Distance")
ElementName
CutOffAValue
CutOffAValue
nrow(ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffAValue)))
nrow(ElementCountDF %>%
filter(UQ(as.symbol(ElementName) >= CutOffAValue)))
min((ElementCountDF %>%
filter(UQ(as.symbol(ElementName)) >= CutOffAValue)))$Distance)
min((ElementCountDF %>%
filter(UQ(as.symbol(ElementName)) >= CutOffAValue))$Distance)
max((ElementCountDF %>%
filter_(paste(ElementName, ">=", CutOffBValue)))$"Distance")
max((ElementCountDF %>%
filter(UQ(as.symbol(ElementName)) >= CutOffBValue))$Distance)
source('~/GitHub/APT-Data-Analysis/GB Analysis New/Grain Boundary Analysis.R')
source('~/GitHub/APT-Data-Analysis/GB Analysis New/Grain Boundary Analysis.R')
